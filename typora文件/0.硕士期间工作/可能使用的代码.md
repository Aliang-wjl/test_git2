```python
# 导包
# 保证在jupyter中的一个cell可以输出多个结果
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "last_expr"

# 滤波代码------------------------------------------------------------------------------------------------------------------------------------------
# 心电滤波代码
def denoise_ecg(data, wavelet="db8", level=9):   
    """
    这个滤除心电噪音，注意必须用db8，用sym8不行，滤波效果不好。 level=9就够了
    
    _, waves_cwt = nk.ecg_delineate(ecg_signal, rpeaks, sampling_rate=sr, method="dwt") 
    在使用这个包寻找各个波点时，必须使用dwt，使用cwt找的不准
    """
    coeffs = pywt.wavedec(data=data, wavelet=wavelet, level=level)
    # 上面的代码将原信号分解为一个低频的近似分量和八个高频的细节分量：
    cA9,   cD9, cD8, cD7, cD6, cD5, cD4, cD3, cD2, cD1 = coeffs
    #0      1    2    3    4    5    6    7    8    9 
    cA9.fill(0)
    lis_denoise = [5,6,7,8,9]
    for i in lis_denoise:
        threshold = (np.median(np.abs(coeffs[i])) / 0.6745) * (np.sqrt(2 * np.log(len(coeffs[i]))))
        coeffs[i] = pywt.threshold(coeffs[i], threshold)
        
    # 小波反变换,获取去噪后的信号
    rdata = pywt.waverec(coeffs=coeffs, wavelet=wavelet)
    return rdata


# 心音滤波代码
def denoise_pcg(data, wavelet="sym8", level=9):   
    """
    4 5 6 7 没有进行阈值去噪，因为发现去除了会影响S1初始波峰的寻找
    """
    # 将数据变为 2^8的倍数才可以计算
    coeffs = pywt.wavedec(data=data, wavelet=wavelet, level=level)
    # 上面的代码将原信号分解为一个低频的近似分量和八个高频的细节分量：
    cA9, cD9, cD8, cD7, cD6, cD5, cD4, cD3, cD2, cD1 = coeffs
    #0    1    2    3    4    5    6    7    8    9  
    
    lis_denoise = [0,1,2,3,8,9]
    for i in lis_denoise:
        threshold = (np.median(np.abs(coeffs[i])) / 0.6745) * (np.sqrt(2 * np.log(len(coeffs[i]))))
        coeffs[i] = pywt.threshold(coeffs[i], threshold)
        
    # 小波反变换,获取去噪后的信号
    rdata = pywt.waverec(coeffs=coeffs, wavelet=wavelet)
    return rdata

# FFT变换代码---------------------------------------------------------------------------------------------------------------------------------------------
def apply_fft_pw(data,smaple_freq):
    """
    这是对FFT代码的变体，确保得到的结果符合我们的预期。
    """
    N = len(data)
    # 进行FFT变换
    fft_data = fft(data)
    #取绝对值，并归一化
    fft_amp0 = np.array(np.abs(fft_data)/N*2)
    # 0Hz频率 FFT变换完第一个数时0Hz频率,0Hz就是没有波动,没有波动有个专业一点的说法,叫直流分量
    # 乘以0以防值过大，对后续判断造成影响（之前乘以了0.5发现会影响我们的结果）
    fft_amp0[0] = 0 * fft_amp0[0]
    # 只需要一半的数据，因为是FFT变换完是对称的
    fft_amp1 = fft_amp0[0:int(N/2)]
    #构造绘图所用的x
    list1 = np.array(range(0,int(N/2)))
    # 转换成频率，注意精度为 0-sample_fre/2 (hz)  例如原始采样率为1000hz，经过fft变换完之后，最大频率为500hz
    freq1 = smaple_freq*list1/N
    # 对最大值点查看对应的频率为多少  最大值点和最大的频率点是不一样的，那个频率点的值大就说明在改点的能量较高
    f_base = freq1[np.argmax(fft_amp1)]
    #返回了三个参数，最大值点的频率，频率点列表以及fft变换之后的一半数据
    return f_base,freq1,fft_amp1

# 波形分解代码------------------------------------------------------------------------------------------------------------------------------------------
def see_resolve(data,wavelet="sym8",level=8):
    # 确保只显示图形
    InteractiveShell.ast_node_interactivity = "last_expr"
    # 分解
    coeffs = pywt.wavedec(data=data, wavelet=wavelet, level=level)
    cA8, cD8, cD7, cD6, cD5, cD4, cD3, cD2, cD1 = coeffs
    # 上面的代码将原信号分解为一个低频的近似分量和九个高频的细节分量
#     cA5, cD5, cD4, cD3, cD2, cD1 = coeffs
    fig1 = plt.figure(figsize = (15,15))
    
    ax1 = fig1.add_subplot(431)
    ax2 = fig1.add_subplot(432)
    ax3 = fig1.add_subplot(433)
    ax4 = fig1.add_subplot(434)
    ax5 = fig1.add_subplot(435)
    ax6 = fig1.add_subplot(436)
    ax7 = fig1.add_subplot(437)
    ax8 = fig1.add_subplot(438)
    ax9 = fig1.add_subplot(439)
    # ax10 = fig1.add_subplot(4,3,10)

    ax1.set_title("cA8")
    ax1.plot(cA8)
    ax2.set_title("cD1")
    ax2.plot(cD1)
    ax3.set_title("cD2")
    ax3.plot(cD2)
    ax4.set_title("cD3")
    ax4.plot(cD3)
    ax5.set_title("cD4")
    ax5.plot(cD4)
    ax6.set_title("cD5")
    ax6.plot(cD5)
    ax7.set_title("cD6")
    ax7.plot(cD6)
    ax8.set_title("cD7")
    ax8.plot(cD7)
    ax9.set_title("cD8")
    ax9.plot(cD8)
# 波形绘制代码------------------------------------------------------------------------------------------------------------------------------------------
def plot_y(y, title=None):
    # 只需要传入y轴数据即可
    plt.figure(figsize=(12, 3.5), dpi=300)
    plt.plot(y, linewidth=1)
    plt.title(title,fontsize = 16)
    plt.tick_params(labelsize=12)
    plt.grid()
    plt.show()
# plot_signal(amplitude_envelope, title='envelope')

def plot_xy(x,y, title=None):
    # 需要传入x轴，y轴数据
    plt.figure(figsize=(12, 3.5), dpi=300)
    plt.plot(x,y, linewidth=1)
    plt.title(title,fontsize = 16)
    plt.tick_params(labelsize=12)
    plt.grid()
    plt.show()

def readMp3_convert_wav(read_mp3, save_wav):
    """
    读取MP3文件，并将MP3文件转换为wav文件并进行保存
    """
    sound = AudioSegment.from_mp3(read_mp3)
    left = sound.split_to_mono()[0]
    bit_depth = left.sample_width * 8
    array_type = get_array_type(bit_depth)
    left_numeric_array = array.array(array_type, left._data)
    # left_channel即为转换出来的数据，可以直接进行绘图
    left_channel = np.array(left_numeric_array) / 32768
    wave_data = np.vstack([left_channel])
    sf.write(save_wav,  wave_data.T, 44100)
    return left_channel

# # 测试代码
# read_mp3 =  r'F:/pytorch_data/hs_data/Michigan_four/Normal/mp3/01.mp3'
# save_wav =  r'F:/pytorch_data/hs_data/Michigan_four/Normal/01.wav'
# data = readMp3(read_mp3, save_wav)
```

